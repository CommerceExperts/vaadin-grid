<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};
  Vaadin.Grid = Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.ScrollMixin = superClass => class ScrollMixin extends superClass {

    get _timeouts() {
      return {
        SCROLLING: 100,
        IGNORE_WHEEL: 500
      };
    }

    static get properties() {
      return {

        _frozenCells: {
          type: Array,
          value: () => [],
        },

        _rowWithFocusedElement: Element
      };
    }

    ready() {
      super.ready();
      this.scrollTarget = this.$.table;

      this.addEventListener('wheel', this._onWheel);

      this.$.items.addEventListener('focusin', (e) => {
        const itemsIndex = e.composedPath().indexOf(this.$.items);
        this._rowWithFocusedElement = e.composedPath()[itemsIndex - 1];
      });
      this.$.items.addEventListener('focusout', () => this._rowWithFocusedElement = undefined);
    }

    _onWheel(e) {
      if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
        return;
      }

      var table = this.$.table;

      var deltaY = e.deltaY;
      if (e.deltaMode === 1) {
        // Mode 1 == scrolling by lines instead of pixels
        deltaY *= this._physicalAverage;
      }

      var momentum = Math.abs(e.deltaX) + Math.abs(deltaY);

      if (this._canScroll(table, e.deltaX, deltaY)) {
        e.preventDefault();
        table.scrollTop += deltaY;
        table.scrollLeft += e.deltaX;
        this._scrollHandler();
        this._hasResidualMomentum = true;

        this._ignoreNewWheel = true;
        this._debouncerIgnoreNewWheel = Polymer.Debouncer.debounce(
          this._debouncerIgnoreNewWheel,
          Polymer.Async.timeOut.after(this._timeouts.IGNORE_WHEEL),
          () => this._ignoreNewWheel = false
        );
      } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
        e.preventDefault();
      } else if (momentum > this._previousMomentum) {
        this._hasResidualMomentum = false;
      }
      this._previousMomentum = momentum;
    }

    /**
     * Determines if the element has an ancestor prior to this
     * cell content that handles the scroll delta
     */
    _hasScrolledAncestor(el, deltaX, deltaY) {
      if (this._canScroll(el, deltaX, deltaY)) {
        return true;
      } else if (el.localName !== 'vaadin-grid-cell-content' && el !== this && el.parentElement) {
        return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
      }
    }

    /**
     * Determines if the the given scroll deltas can be applied to the element
     * (fully or partially)
     */
    _canScroll(el, deltaX, deltaY) {
      return (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||
      (deltaY < 0 && el.scrollTop > 0) ||
      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||
      (deltaX < 0 && el.scrollLeft > 0);
    }

    _scheduleScrolling() {
      if (!this._scrollingFrame) {
        // Defer setting state attributes to avoid Edge hiccups
        this._scrollingFrame = requestAnimationFrame(() => this._toggleAttribute('scrolling', true, this.$.scroller));
      }
      this._debounceScrolling = Polymer.Debouncer.debounce(
        this._debounceScrolling,
        Polymer.Async.timeOut.after(this._timeouts.SCROLLING),
        () => {
          cancelAnimationFrame(this._scrollingFrame);
          delete this._scrollingFrame;
          this._toggleAttribute('scrolling', false, this.$.scroller);
          this._reorderRows();
        }
      );
    }

    _afterScroll() {
      this._translateStationaryElements();

      if (!this.hasAttribute('reordering')) {
        this._scheduleScrolling();
      }

      this._updateOverflow();
    }

    _updateOverflow() {
      // Set overflow styling attributes
      let overflow = '';
      const table = this.$.table;
      if (table.scrollTop < table.scrollHeight - table.clientHeight) {
        overflow += ' bottom';
      }

      if (table.scrollTop > 0) {
        overflow += ' top';
      }

      if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
        overflow += ' right';
      }

      if (table.scrollLeft > 0) {
        overflow += ' left';
      }

      this._debounceOverflow = Polymer.Debouncer.debounce(
        this._debounceOverflow,
        Polymer.Async.animationFrame,
        () => {
          const value = overflow.trim();
          if (value.length > 0 && this.getAttribute('overflow') !== value) {
            this.setAttribute('overflow', value);
          } else if (value.length == 0 && this.hasAttribute('overflow')) {
            this.removeAttribute('overflow');
          }
        }
      );
    }

    // correct order needed for preserving correct tab order between cell contents.
    _reorderRows() {
      const body = this.$.items;
      const items = body.querySelectorAll('tr');
      if (!items.length) {
        return;
      }

      const adjustedVirtualStart = this._virtualStart + this._vidxOffset;

      // Which row to use as a target?
      const targetRow = this._rowWithFocusedElement || Array.from(items).filter(row => !row.hidden)[0];
      if (!targetRow) {
        // All rows are hidden, don't reorder
        return;
      }

      // Where the target row should be?
      const targetPhysicalIndex = targetRow.index - adjustedVirtualStart;

      // Reodrer the DOM elements to keep the target row at the target physical index
      const delta = Array.from(items).indexOf(targetRow) - targetPhysicalIndex;
      if (delta > 0) {
        for (let i = 0; i < delta; i++) {
          body.appendChild(items[i]);
        }
      } else if (delta < 0) {
        for (let i = items.length + delta; i < items.length; i++) {
          body.insertBefore(items[i], items[0]);
        }
      }
    }

    _frozenCellsChanged() {
      this._debouncerCacheElements = Polymer.Debouncer.debounce(
        this._debouncerCacheElements,
        Polymer.Async.microTask,
        () => {
          Array.from(this.root.querySelectorAll('[part~="cell"]')).forEach(function(cell) {
            cell.style.transform = '';
          });
          this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll('[frozen]'));
          this._translateStationaryElements();
        }
      );
      this._updateLastFrozen();
    }

    _updateLastFrozen() {
      if (!this._columnTree) {
        return;
      }

      const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);
      columnsRow.sort((a, b) => {
        return a._order - b._order;
      });
      const lastFrozen = columnsRow.reduce((prev, col, index) => {
        col._lastFrozen = false;
        return col.frozen && !col.hidden ? index : prev;
      }, undefined);
      if (lastFrozen !== undefined) {
        columnsRow[lastFrozen]._lastFrozen = true;
      }
    }

    _translateStationaryElements() {
      const scrollLeft = Math.max(0, this._scrollLeft); // TODO: Min
      const scrollTop = Math.max(0, this._scrollTop);
      
      let leftOffset = 0;
      let topOffset = 0;
      let footerOffset = 0;
      if (!this._useSticky) {
        leftOffset = scrollLeft;
        topOffset = scrollTop;
        footerOffset = this.$.table.clientHeight - this.$.footer.offsetHeight - this.$.footer.offsetTop;
      }

      this.$.header.style.transform = this._getTranslate(-scrollLeft + leftOffset, topOffset);
      this.$.footer.style.transform = this._getTranslate(-scrollLeft + leftOffset, topOffset + footerOffset);
      this.$.items.style.transform = this._getTranslate(-scrollLeft + leftOffset, 0);

      const frozenCellsTranslate = this._getTranslate(scrollLeft, 0);
      this._frozenCells.forEach(cell => cell.style.transform = frozenCellsTranslate);
    }

    get _useSticky() {
      // if (this._nativeStickyValue === undefined) {
        this._nativeStickyValue = getComputedStyle(this.$.items).position.indexOf('sticky') !== -1;
      // }
      return this._nativeStickyValue;
    }

    _getTranslate(x, y) {
      return `translate(${x}px, ${y}px)`;
    }

  };
</script>
