<link rel="import" href="vaadin-grid-scroller.html">
<link rel="import" href="vaadin-grid-dynamic-columns-mixin.html">
<link rel="import" href="vaadin-grid-data-provider-mixin.html">
<link rel="import" href="vaadin-grid-array-data-provider-mixin.html">
<link rel="import" href="vaadin-grid-cell-click-mixin.html">
<link rel="import" href="vaadin-grid-active-item-mixin.html">
<link rel="import" href="vaadin-grid-scroll-mixin.html">
<link rel="import" href="vaadin-grid-selection-mixin.html">
<link rel="import" href="vaadin-grid-sort-mixin.html">
<link rel="import" href="vaadin-grid-row-details-mixin.html">
<link rel="import" href="vaadin-grid-keyboard-navigation-mixin.html">
<link rel="import" href="vaadin-grid-filter-mixin.html">
<link rel="import" href="vaadin-grid-column-reordering-mixin.html">
<link rel="import" href="vaadin-grid-column-resizing-mixin.html">
<link rel="import" href="vaadin-grid-column.html">
<link rel="import" href="vaadin-grid-outer-scroller.html">
<link rel="import" href="vaadin-grid-styles.html">

<dom-module id="vaadin-grid">
  <template>
  <style>
    @keyframes vaadin-grid-appear {
      to {
        opacity: 1;
      }
    }

    :host {
      display: block;
      animation: 1ms vaadin-grid-appear;
      height: 400px;
    }

    #scroller {
      display: block;
      position: relative;
      height: 100%;
      width: 100%;
      transform: translateZ(0);
    }

    #table {
      display: block;
      width: 100%;
      height: 100%;
      overflow: auto;
      z-index: -2;
      position: relative;
    }

    #header {
      display: block;
      position: absolute;
      top: 0;
      width: 100%;
    }

    [part~="header-cell"] {
      font-weight: 500;
      text-align: left;
    }

    #footer {
      display: block;
      position: absolute;
      bottom: 0;
      width: 100%;
    }

    #items {
      display: block;
      width: 100%;
      height: 100%;
      position: relative;
      z-index: -1;
    }

    #items,
    #outersizer,
    #fixedsizer {
      border-top: 0 solid transparent;
      border-bottom: 0 solid transparent;
    }

    [part~="row"] {
      display: flex;
      width: 100%;
      box-sizing: border-box;
      margin: 0;
    }

    #items [part~="row"] {
      position: absolute;
    }

    #items [part~="row"]:empty {
      height: 1em;
    }

    [part~="cell"]:not([part~="details-cell"]) {
      padding: 0;
      flex-shrink: 0;
      flex-grow: 1;
      box-sizing: border-box;
      display: flex;
      width: 100%;
      position: relative;
    }

    [part~="details-cell"] {
      position: absolute;
      bottom: 0;
      width: 100%;
      box-sizing: border-box;
    }

    [part~="cell"]:not([part~="details-cell"]) ::slotted(vaadin-grid-cell-content) {
      width: 100%;
      display: inline-flex;
      justify-content: center;
      flex-direction: column;
      white-space: nowrap;
      overflow: hidden;
    }

    [hidden] {
      display: none !important;
    }

    [frozen] {
      z-index: 2;
    }

    #outerscroller {
      /* Needed for Android Chrome */
      z-index: 0;
    }

    [no-scrollbars]:not([safari]) #outerscroller,
    [no-scrollbars][safari] #table {
      overflow: hidden;
    }

    [ios] #outerscroller {
      pointer-events: auto;
      z-index: -3;
    }

    [ios][scrolling] #outerscroller {
      z-index: 0;
    }

    /* Sizer styles */
    #outersizer {
      display: flex;
      position: relative;
      width: 100%;
      visibility: hidden;
    }

    #outersizer [part~="details-cell"] {
      display: none;
    }

    #outersizer [part~="cell"] {
      display: block;
      flex-shrink: 0;
      line-height: 0;
      font-size: 1px;
      margin-top: -1em;
    }

    #outersizer [part~="cell"][hidden] {
      display: none;
    }

    #outersizer [part~="cell"] {
      height: 0px !important;
      padding: 0px !important;
    }

    #outersizer [part~="cell"]::before {
      content: "-";
    }

    #outersizer [part~="cell"] ::slotted(*) {
      display: none;
    }

    #fixedsizer {
      /* TODO: fix*/
      display: none;
    }

      :host {
        border: 1px solid #dbdbdb;
      }

      [part~="row"]:last-child [part~="header-cell"],
      [part~="body-cell"],
      [part~="details-cell"] {
        border-bottom: 1px solid #dbdbdb;
      }

      [part~="row"]:first-child [part~="footer-cell"] {
        border-top: 1px solid #dbdbdb;
      }

      [part~="cell"]:not(:empty):not([details-cell]) {
        padding: 8px;
      }

      [part~="cell"] {
        background: #fff;
      }

      [part~="cell"][last-frozen] {
        border-right: 1px solid #dbdbdb;
      }

      :host([reordering]) [part~="cell"] {
        background: #f0f0f0;
      }

      :host([reordering]) [part~="cell"][reorder-status="allowed"] {
        background: #ffffff;
      }

      :host([reordering]) [part~="cell"][reorder-status="dragging"] {
        background: #ece9ec;
      }

      [part~="row"][selected] [part~="body-cell"] {
        background-color: #f5f5f5;
      }

      [part="resize-handle"] {
        border-right: 1px solid #dbdbdb;
        right: -1px;
      }

      [part~="cell"]:focus {
        outline: none;
      }

      :host([navigating]) [part~="cell"]:focus {
        box-shadow: inset 0 0 0 3px rgba(0,0,0,.25);
      }

      [part~="resize-handle"] {
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        cursor: col-resize;
        z-index: 1;
      }

      [part~="resize-handle"]::before {
        position: absolute;
        content: "";
        height: 100%;
        width: 35px;
        transform: translateX(-50%);
      }

      [lastcolumn] [part~="resize-handle"]::before,
      [last-frozen] [part~="resize-handle"]::before {
        width: 18px;
        transform: translateX(-100%);
      }

      #scroller[column-resizing] {
        -ms-user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        user-select: none;
      }

      :host([reordering]) [part~="cell"] ::slotted(vaadin-grid-cell-content),
      #scroller[no-content-pointer-events] [part~="cell"] ::slotted(vaadin-grid-cell-content) {
        pointer-events: none;
      }

      #reorderghost {
        visibility: hidden;
        position: fixed;
        opacity: 0.5;
        pointer-events: none;
      }

      :host([reordering]) {
        -ms-user-select: none;
        -moz-user-select: none;
        -webkit-user-select: none;
        user-select: none;
      }

      :host([reordering]) #outerscroller {
        -webkit-overflow-scrolling: auto !important;
      }
    </style>

    <div id="scroller" no-scrollbars$="[[!_scrollbarWidth]]" safari$="[[_safari]]" ios$="[[_ios]]" scrolling$="[[scrolling]]" loading$=[[_loading]]>
      <table id="table" role="application grid">
        <caption>
          <!-- TODO: Implement -->
          <div id="fixedsizer"></div>
        </caption>
        <thead id="header" role="rowgroup"></thead>
        <tbody id="items" role="rowgroup"></tbody>
        <tfoot id="footer" role="rowgroup"></tfoot>
      </table>

      <div id="reorderghost"></div>
      <vaadin-grid-outer-scroller id="outerscroller"
          scroll-target="[[scrollTarget]]"
          scroll-handler="[[_this]]">
          &nbsp;
        <div id="outersizer" part='row' style$="top: [[_estScrollHeight]]px"></div>
      </vaadin-grid-outer-scroller>
    </div>

    <!-- The template needs at least one slot or else shady doesn't distribute -->
    <slot name="nodistribute"></slot>

    <div id="focusexit" tabindex="0"></div>
  </template>
</dom-module>

<script>
  /**
   * ### Styling
   *
   * The following shadow DOM parts are exposed for styling:
   *
   * Part name | Description
   * ----------------|----------------
   * `row` | Row in the internal table
   * `cell` | Cell in the internal table
   * `header-cell` | Header cell in the internal table
   * `body-cell` | Body cell in the internal table
   * `footer-cell` | Footer cell in the internal table
   * `details-cell` | Row details cell in the internal table
   * `resize-handle` | Handle for resizing the columns
   *
   * @memberof Vaadin
   * @mixes Vaadin.ThemableMixin
   */
  class VaadinGrid extends
    Vaadin.Grid.DataProviderMixin(
    Vaadin.Grid.ArrayDataProviderMixin(
    Vaadin.Grid.DynamicColumnsMixin(
    Vaadin.Grid.CellClickMixin(
    Vaadin.Grid.ActiveItemMixin(
    Vaadin.Grid.ScrollMixin(
    Vaadin.Grid.SelectionMixin(
    Vaadin.Grid.SortMixin(
    Vaadin.Grid.RowDetailsMixin(
    Vaadin.Grid.KeyboardNavigationMixin(
    Vaadin.Grid.FilterMixin(
    Vaadin.Grid.ColumnReorderingMixin(
    Vaadin.Grid.ColumnResizingMixin(
    Vaadin.Grid.VaadinGridScroller))))))))))))) {

    static get is() {
      return 'vaadin-grid';
    }

    static get observers() {
      return [
        '_columnTreeChanged(_columnTree, _columnTree.*)',
      ]
    }

    static get properties() {
      return {

        _safari: {
          type: Boolean,
          value: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        },

        _this: {
          type: Object,
          value: function() {
            return this;
          }
        },

        _ios: {
          type: Boolean,
          value: function() {
            return navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/);
          }
        }

      }
    }

    constructor() {
      super();
      this.addEventListener('animationend', this._onAnimationEnd);
    }

    _createScrollerRows(count) {
      const rows = [];
      for (var i = 0; i < count; i++) {
        const row = document.createElement('tr');
        row.setAttribute('part', 'row');
        row.setAttribute('role', 'row');
        if (this._columnTree) {
          this._updateRow(row, this._columnTree[this._columnTree.length - 1], 'body', false, true);
        }
        rows.push(row);
      }

      if (this._columnTree) {
        this._columnTree[this._columnTree.length - 1].forEach(c => c.notifyPath('_cells.*', c._cells));
      }

      Polymer.RenderStatus.beforeNextRender(this, this._resetKeyboardNavigation);
      return rows;
    }

    _getRowTarget() {
      return this.$.items;
    }

    _createCell(tagName) {
      const contentId = this._contentIndex = this._contentIndex + 1 || 0;
      const slotName = 'vaadin-grid-cell-content-' + contentId;

      const cellContent = document.createElement('vaadin-grid-cell-content');
      cellContent.setAttribute('slot' , slotName);

      const cell = document.createElement(tagName);
      cell.id = slotName.replace('-content-', '-');
      cell.setAttribute('tabindex', '-1');
      cell.setAttribute('role', tagName === 'td' ? 'gridcell' : 'columnheader gridcell');

      const slot = document.createElement('slot');
      slot.setAttribute('name', slotName);

      cell.appendChild(slot);

      cell._content = cellContent;

      return cell;
    }

    _updateRow(row, columns, section, isColumnRow, noNotify) {
      section = section || 'body';

      const cellsFragment = document.createDocumentFragment();
      const contentsFragment = document.createDocumentFragment();

      Array.from(row.children).forEach(cell => {
        cell._vacant = true;
      });
      row.innerHTML = '';
      row.hidden = true;
      columns.forEach((column, index) => {
        let cell;

        if (section === 'body') {
          // Body
          column._cells = column._cells || [];
          cell = column._cells.find(cell => cell._vacant);
          if (!cell) {
            cell = this._createCell('td');
            column._cells.push(cell);
          }
          cell.setAttribute('part', 'cell body-cell');
          row.appendChild(cell);

          if (index === columns.length - 1 && this._rowDetailsTemplate) {
            // Add details cell as last cell to body rows
            this._detailsCells = this._detailsCells || [];
            const detailsCell = this._detailsCells.find(cell => cell._vacant) || this._createCell('td');
            if (this._detailsCells.indexOf(detailsCell) === -1) {
              this._detailsCells.push(detailsCell);
            }
            if (!detailsCell._content.parentElement) {
              contentsFragment.appendChild(detailsCell._content);
            }
            this._configureDetailsCell(detailsCell);
            row.appendChild(detailsCell);
            detailsCell._vacant = false;
          }

          if (column.notifyPath && !noNotify) {
            column.notifyPath('_cells.*', column._cells);
          }

          const descriptionCell = column._headerCell || column._footerCell;
          if (descriptionCell) {
            cell.setAttribute('aria-labelledby', `${descriptionCell.id} ${cell.id}`);
          }
        } else {
          // Header & footer
          row.hidden = true;
          const tagName = section === 'header' ? 'th' : 'td';
          if (isColumnRow || column.localName === 'vaadin-grid-column-group') {
            cell = column[`_${section}Cell`] || this._createCell(tagName);
            row.appendChild(cell);
            if (cell._instance) {
              row.hidden = false;
            }
            column[`_${section}Cell`] = cell;
          } else {
            column._emptyCells = column._emptyCells || [];
            cell = column._emptyCells.find(cell => cell._vacant) || this._createCell(tagName);
            row.appendChild(cell);
            if (column._emptyCells.indexOf(cell) === -1) {
              column._emptyCells.push(cell);
            }
          }
          cell.setAttribute('part', `cell ${section}-cell`);
        }

        if (!cell._content.parentElement) {
          contentsFragment.appendChild(cell._content);
        }
        cell._vacant = false;
        cell._column = column;
      });

      // Might be empty if only cache was used
      this.appendChild(contentsFragment);

      this._frozenCellsChanged();
      this._updateLastColumn();
    }

    _updateScrollerItem(row, index) {
      if (!this._columnTree) {
        return;
      }

      Array.from(row.children).forEach(cell => {
        if (cell._instance) {
          cell._instance.index = index;
        }
      });
      this._toggleAttribute('odd', index % 2, row);
      this._getItem(index, row);
    }

    _columnTreeChanged(columnTree, splices) {
      Array.from(this.$.items.children).forEach(row => {
        this._updateRow(row, columnTree[columnTree.length - 1]);
      });

      // TODO: DRY
      while (this.$.header.children.length < columnTree.length) {
        const headerRow = document.createElement('tr');
        headerRow.setAttribute('part', 'row');
        headerRow.setAttribute('role', 'row');
        this.$.header.appendChild(headerRow);

        const footerRow = document.createElement('tr');
        footerRow.setAttribute('part', 'row');
        footerRow.setAttribute('role', 'row');
        this.$.footer.appendChild(footerRow);
      }
      while (this.$.header.children.length > columnTree.length) {
        this.$.header.removeChild(this.$.header.firstElementChild);
        this.$.footer.removeChild(this.$.footer.firstElementChild);
      }

      Array.from(this.$.header.children).forEach((headerRow, index) => {
        this._updateRow(headerRow, columnTree[index], 'header', index === columnTree.length - 1);
      });

      Array.from(this.$.footer.children).forEach((footerRow, index) => {
        this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], 'footer', index === 0);
      });

      Array.from(this.$.items.children).forEach((row, index) => {
        this._updateRow(row, columnTree[columnTree.length - 1]);
      });

      // Sizer row
      this._updateRow(this.$.outersizer, columnTree[columnTree.length - 1]);

      this._resizeHandler();
      this._frozenCellsChanged();
      this._updateLastColumn();
      this._resetKeyboardNavigation();
    }

    _updateItem(row, item) {
      // row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
      row._item = item;
      Array.from(row.children).forEach((cell) => {
        if (cell._instance) {
          cell._instance.item = item;
          cell._instance.__expanded__ = this._isExpanded(item);
          cell._instance.expanded = this._isExpanded(item);
          cell._instance.__selected__ = this._isSelected(item);
          cell._instance.selected = this._isSelected(item);
        }
      });
      this._toggleAttribute('selected', this._isSelected(item), row);
      if (this._rowDetailsTemplate) {
        this._toggleDetailsCell(row, item);
      }
    }

    _resizeHandler() {
      this._updateDetailsCellHeights();
      super._resizeHandler();
      this._updateHeaderFooterMetrics();
    }

    _updateHeaderFooterMetrics() {
      var headerHeight = this.$.header.clientHeight + 'px';
      var footerHeight = this.$.footer.clientHeight + 'px';
      [this.$.outersizer, this.$.fixedsizer, this.$.items].forEach(function(element) {
        element.style.borderTopWidth = headerHeight;
        element.style.borderBottomWidth = footerHeight;
      });
    }

    _onAnimationEnd(e) {
      if (e.animationName === 'vaadin-grid-appear') {
        this._render();
        this._updateHeaderFooterMetrics();
        e.stopPropagation();
      }
    }

    _toggleAttribute(name, bool, node) {
      if (bool) {
        node.setAttribute(name, '');
      } else {
        node.removeAttribute(name);
      }
    }

    ready() {
      super.ready();

      if (document.doctype === null) {
        console.warn(
          '<vaadin-grid> requires the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
        );
      }
    }

  }

  customElements.define(VaadinGrid.is, VaadinGrid);
</script>
