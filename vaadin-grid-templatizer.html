<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<link rel="import" href="../polymer/polymer.html">

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};
  vaadin.elements.grid.Templatizer = Polymer({
    is: 'vaadin-grid-templatizer',

    behaviors: [Polymer.Templatizer],

    properties: {
      dataHost: Object,
      template: Object,

      _templateInstances: {
        type: Array,
        value: function() {
          return [];
        }
      },

      _parentPathValues: {
        value: function() {
          return {};
        }
      },

      _grid: Object
    },

    observers: [
      '_templateInstancesChanged(_templateInstances.*, _parentPathValues.*)'
    ],

    created: function() {
      // needed for V2 to enable event.model on declarative event listeners.
      this._parentModel = true;

      this._instanceProps = {
        expanded: true,
        index: true,
        item: true,
        selected: true
      };
    },

    createInstance: function() {
      this._ensureTemplatized();
      var instance = this.stamp({});
      this.addInstance(instance);

      return instance;
    },

    addInstance: function(instance) {
      if (this._templateInstances.indexOf(instance) === -1) {
        this._templateInstances.push(instance);
        requestAnimationFrame(() => this.notifyPath('_templateInstances.*', this._templateInstances));
      }
    },

    removeInstance: function(instance) {
      var index = this._templateInstances.indexOf(instance);
      this.splice('_templateInstances', index, 1);
    },

    _ensureTemplatized: function() {
      // Avoid multiple templatize for the template
      if (!this.template._templatized) {
        this.template._templatized = true;

        this.templatize(this.template);

        // TODO: hack to avoid: https://github.com/Polymer/polymer/issues/3307
        this._parentProps = this._parentProps || {};
      }
    },

    _notifyInstancePropV2: function(inst, prop, value) {
      if (prop === 'index' || prop === 'item') {
        // We donâ€™t need a change notification for these.
        return;
      }

      var originalProp = `__${prop}__`;

      // Notify for only user-action changes, not for scrolling updates. E. g.,
      // if `expanded` is different from `__expanded__`, which was set during render.
      if (inst[originalProp] === value) {
        return;
      }
      inst[originalProp] = value;

      const row = Array.from(this._grid.$.items.children).filter(row => row._item === inst.item)[0];
      if (row) {
        Array.from(row.children).forEach(cell => {
          cell._instance[originalProp] = value;
          cell._instance.notifyPath(prop, value);
        });
      }

      var gridCallback = `_${prop}InstanceChangedCallback`;
      if (this._grid && this._grid[gridCallback]) {
        this._grid[gridCallback](inst, value);
      }
    },

    _forwardParentProp: function(prop, value) {
      this._parentPathValues[prop] = value;
      this._templateInstances.forEach(function(inst) {
        inst.set(prop, value);
      }, this);
    },

    _forwardParentPath: function(path, value) {
      this.set(['_parentPathValues', path], value);
      this._templateInstances.forEach(function(inst) {
        inst.notifyPath(path, value);
      }, this);
    },

    _forwardHostPropV2: function(prop, value) {
      this._forwardParentProp(prop, value);

      // TODO: _forwardedParentPropsChanged isn't triggered for some reason in
      // all cases in Hybrid mode. Try removing this after running pure P2.
      if (this._templateInstances) {
        this._templateInstances.forEach(function(inst) {
          inst.notifyPath(prop, value);
        }, this);
      }
    },

    _templateInstancesChanged: function(t, p) {
      var index, count;
      if (t.path === '_templateInstances') {
        // Iterate all instances
        index = 0;
        count = this._templateInstances.length;
      } else if (t.path === '_templateInstances.splices') {
        // Iterate only new instances
        index = t.value.index;
        count = t.value.addedCount;
      } else {
        return;
      }
      Object.keys(this._parentPathValues || {}).forEach(function(keyName) {
        for (var i = index; i < index + count; i++) {
          this._templateInstances[i].set(keyName, this._parentPathValues[keyName]);
        }
      }, this);
    }

  });
</script>
